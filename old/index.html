<canvas id="solar"></canvas>



<script>
const canvas = document.getElementById("solar");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// Planetas com períodos reais (simplificados)
const planets = [
  { name: "Mercury", radius: 60,  size: 4,  periodDays: 88,    angleOffset: 0 },
  { name: "Venus",   radius: 90,  size: 6,  periodDays: 225,   angleOffset: 1 },
  { name: "Earth",   radius: 130, size: 7,  periodDays: 365,   angleOffset: 2 },
  { name: "Mars",    radius: 170, size: 5,  periodDays: 687,   angleOffset: 3 },
  { name: "Jupiter", radius: 220, size: 11, periodDays: 4333,  angleOffset: 0.5 },
  { name: "Saturn",  radius: 270, size: 10, periodDays: 10759, angleOffset: 1.5, hasRings: true },
  { name: "Uranus",  radius: 320, size: 8,  periodDays: 30687, angleOffset: 0.2 },
  { name: "Neptune", radius: 370, size: 8,  periodDays: 60190, angleOffset: 2.3 }
];

// Tempo simulado (quase estático)
const DAYS_PER_SECOND = 0.01; // diminua se quiser ainda mais devagar
const startTime = performance.now();

// “Câmera” em coordenadas do mundo (em torno do Sol)
let zoom = 1;
let targetZoom = 1;
let camX = 0;
let camY = 0;
let targetCamX = 0;
let targetCamY = 0;
let focusedPlanet = null;

// Clique: foco / desfoco
canvas.addEventListener("click", (e) => {
  const rect = canvas.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Verifica se clicou em algum planeta (usando screenX/screenY calculados no draw)
  let clicked = null;
  for (const p of planets) {
    if (p.screenX === undefined) continue;
    const dist = Math.hypot(clickX - p.screenX, clickY - p.screenY);
    if (dist < p.size * zoom + 10) {
      clicked = p;
      break;
    }
  }

  // Clique no vazio → volta visão geral
  if (!clicked) {
    focusedPlanet = null;
    targetZoom = 1;
    targetCamX = 0;
    targetCamY = 0;
    return;
  }

  if (focusedPlanet === clicked) {
    // Já estava focado → desfoca
    focusedPlanet = null;
    targetZoom = 1;
    targetCamX = 0;
    targetCamY = 0;
  } else {
    // Foca novo planeta
    focusedPlanet = clicked;

    // Zoom bem mais detalhado
    targetZoom = 4.5; // aumenta/diminui para definir quão perto fica

    // Centraliza o planeta usando posição em coordenadas do mundo
    // (essas coords são atualizadas no draw: p.worldX / p.worldY)
    if (typeof clicked.worldX === "number" && typeof clicked.worldY === "number") {
      targetCamX = -clicked.worldX;
      targetCamY = -clicked.worldY;
    }
  }
});

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Fundo
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.save();

  // Move para o centro da tela
  ctx.translate(canvas.width / 2, canvas.height / 2);

  // Aplica zoom
  ctx.scale(zoom, zoom);

  // Aplica câmera em coordenadas do mundo (em torno do Sol)
  ctx.translate(camX, camY);

  // Tempo simulado
  const now = performance.now();
  const elapsedSeconds = (now - startTime) / 1000;
  const simulatedDays = elapsedSeconds * DAYS_PER_SECOND;

  // Órbitas
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.lineWidth = 1 / zoom;
  for (const p of planets) {
    ctx.beginPath();
    ctx.arc(0, 0, p.radius, 0, Math.PI * 2);
    ctx.stroke();
  }

  // Sol
  const sunRadius = 20;
  const gradient = ctx.createRadialGradient(0,0,0, 0,0,sunRadius*2);
  gradient.addColorStop(0, "#fff9d9");
  gradient.addColorStop(1, "#ffb84d");
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(0, 0, sunRadius, 0, Math.PI * 2);
  ctx.fill();

  // Planetas
  for (const p of planets) {
    // Ângulo baseado em dias simulados
    const orbitFraction = simulatedDays / p.periodDays;
    const angle = orbitFraction * Math.PI * 2 + p.angleOffset;

    const x = Math.cos(angle) * p.radius;
    const y = Math.sin(angle) * p.radius;

    // Guarda posição em coordenadas do mundo
    p.worldX = x;
    p.worldY = y;

    // Desenhar planeta
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = "lightblue";
    ctx.beginPath();
    ctx.arc(0, 0, p.size, 0, Math.PI * 2);
    ctx.fill();

    // Anéis de Saturno
    if (p.hasRings) {
      ctx.strokeStyle = "rgba(255,255,255,0.6)";
      ctx.lineWidth = 2 / zoom;
      ctx.beginPath();
      ctx.ellipse(0, 0, p.size * 2.2, p.size * 1.1, 0.4, 0, Math.PI * 2);
      ctx.stroke();
    }

    ctx.restore();

    // Calcula posição em coordenadas de tela para hit-test do clique
    const screenX = canvas.width / 2 + (x + camX) * zoom;
    const screenY = canvas.height / 2 + (y + camY) * zoom;
    p.screenX = screenX;
    p.screenY = screenY;
  }

  ctx.restore();
}

function animate() {
  // Interpolação suave de zoom e câmera
  zoom += (targetZoom - zoom) * 0.08;      // mais responsivo
  camX += (targetCamX - camX) * 0.08;
  camY += (targetCamY - camY) * 0.08;

  draw();
  requestAnimationFrame(animate);
}

animate();
</script>