<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Caminho Cósmico Interativo</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      height: 100%;
      width: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #eee;
    }

    canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    /* Pequena dica de interação no canto */
    .hud {
      position: fixed;
      left: 16px;
      bottom: 16px;
      font-size: 12px;
      color: #aaa;
      background: rgba(0,0,0,0.5);
      padding: 6px 10px;
      border-radius: 6px;
      backdrop-filter: blur(6px);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="spaceCanvas"></canvas>
  <div class="hud">
    Clique em uma lua para focar • Clique de novo ou aperte Esc para voltar
  </div>

  <script>
    // ==========================
    // Setup básico do canvas
    // ==========================
    const canvas = document.getElementById('spaceCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ==========================
    // Coordenadas normalizadas
    // ==========================
    // Todo corpo celeste é definido em coordenadas [0,1] no eixo X e Y.
    // Na hora de desenhar, multiplicamos por largura/altura do canvas.
    function normToPixelX(nx) {
      return nx * canvas.width;
    }

    function normToPixelY(ny) {
      return ny * canvas.height;
    }

    function normRadiusToPixels(nr) {
      return nr * Math.min(canvas.width, canvas.height);
    }

    // ==========================
    // Sistema de câmera
    // ==========================
    // A câmera é definida por:
    // - centerX, centerY: coordenadas normalizadas do ponto central da viewport
    // - scale: zoom (1 = visão geral, >1 = aproximado)
    const camera = {
      current: { x: 0.5, y: 0.5, scale: 1.0 },
      target:  { x: 0.5, y: 0.5, scale: 1.0 },
      lerpFactor: 0.08
    };

    function updateCamera() {
      const c = camera.current;
      const t = camera.target;
      c.x += (t.x - c.x) * camera.lerpFactor;
      c.y += (t.y - c.y) * camera.lerpFactor;
      c.scale += (t.scale - c.scale) * camera.lerpFactor;
    }

    // Aplica a transformação de câmera ao contexto antes de desenhar o mundo.
    function applyCameraTransform() {
      const c = camera.current;
      const cxPix = normToPixelX(c.x);
      const cyPix = normToPixelY(c.y);

      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.scale(c.scale, c.scale);
      ctx.translate(-cxPix, -cyPix);
    }

    // Converte coordenadas de tela (pixel) para coordenadas normalizadas de mundo.
    // Usado para detectar cliques nas luas.
    function screenToWorldNormalized(sx, sy) {
      const c = camera.current;
      const cxPix = normToPixelX(c.x);
      const cyPix = normToPixelY(c.y);

      // Inverso da transformação de câmera
      const worldPixX = (sx - canvas.width / 2) / c.scale + cxPix;
      const worldPixY = (sy - canvas.height / 2) / c.scale + cyPix;

      const nx = worldPixX / canvas.width;
      const ny = worldPixY / canvas.height;
      return { x: nx, y: ny };
    }

    // ==========================
    // Estruturas de dados
    // ==========================

    // Estrelas de fundo: pequenas, com cintilação
    const stars = [];
    const STAR_COUNT = 250;

    function createStars() {
      stars.length = 0;
      for (let i = 0; i < STAR_COUNT; i++) {
        stars.push({
          x: Math.random(),          // normalizado
          y: Math.random(),          // normalizado
          radius: Math.random() * 0.002 + 0.0005, // raio normalizado
          baseAlpha: Math.random() * 0.6 + 0.2,
          twinkleSpeed: Math.random() * 2 + 0.5,
          twinklePhase: Math.random() * Math.PI * 2
        });
      }
    }
    createStars();

    // Parâmetros da trilha luminosa em forma de onda senoidal
    const trail = {
      amplitude: 0.08,   // amplitude vertical em coordenadas normalizadas
      frequency: 3.5,    // frequência da senoide
      phaseSpeed: 0.0004 // velocidade de animação da fase ao longo do tempo
    };

    // Planetas (decorativos, não clicáveis)
    // Cada planeta é posicionado ao longo da diagonal principal (x ~ t, y ~ 1-t)
    const planets = [
      { x: 0.18, y: 0.82, radius: 0.045, colorInner: '#4373ff', colorOuter: '#1624a3', floatPhase: Math.random()*Math.PI*2 },
      { x: 0.40, y: 0.60, radius: 0.055, colorInner: '#ff4444', colorOuter: '#93263c', floatPhase: Math.random()*Math.PI*2 },
      { x: 0.64, y: 0.36, radius: 0.06,  colorInner: '#ff9f4f', colorOuter: '#b35f2f', floatPhase: Math.random()*Math.PI*2, hasRing: true },
      { x: 0.82, y: 0.18, radius: 0.04,  colorInner: '#55ffe3', colorOuter: '#1c7870', floatPhase: Math.random()*Math.PI*2 }
    ];

    // Luas (clicáveis)
    // type, x, y, radius (normalizado), color, phase
    const moons = [
      { id: 1, type: 'moon', x: 0.25, y: 0.75, radius: 0.022, color: '#f5e3a0', phase: 'full',     floatPhase: Math.random()*Math.PI*2 },
      { id: 2, type: 'moon', x: 0.35, y: 0.55, radius: 0.018, color: '#b9c3ff', phase: 'crescent', floatPhase: Math.random()*Math.PI*2 },
      { id: 3, type: 'moon', x: 0.55, y: 0.45, radius: 0.020, color: '#ffd7a3', phase: 'waning',   floatPhase: Math.random()*Math.PI*2 },
      { id: 4, type: 'moon', x: 0.70, y: 0.28, radius: 0.026, color: '#ffecc4', phase: 'full',     floatPhase: Math.random()*Math.PI*2 },
      { id: 5, type: 'moon', x: 0.48, y: 0.68, radius: 0.016, color: '#d7f0ff', phase: 'crescent', floatPhase: Math.random()*Math.PI*2 }
    ];

    // Galáxias / nebulosas (formas suaves, não interativas)
    const nebulas = [
      { x: 0.15, y: 0.25, radius: 0.18, color1: 'rgba(130, 180, 255, 0.7)', color2: 'rgba(20, 40, 80, 0)' },
      { x: 0.65, y: 0.15, radius: 0.22, color1: 'rgba(255, 150, 200, 0.6)', color2: 'rgba(60, 20, 40, 0)' },
      { x: 0.85, y: 0.65, radius: 0.20, color1: 'rgba(170, 255, 200, 0.5)', color2: 'rgba(20, 60, 40, 0)' }
    ];

    // Zoom/foco em lua
    let focusedMoonId = null;

    // ==========================
    // Desenho dos elementos
    // ==========================

    function drawBackground() {
      // Fundo praticamente preto
      ctx.fillStyle = '#02030a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawStars(time) {
      for (const s of stars) {
        const x = normToPixelX(s.x);
        const y = normToPixelY(s.y);
        const r = normRadiusToPixels(s.radius);

        const twinkle = Math.sin(time * s.twinkleSpeed + s.twinklePhase) * 0.3 + 0.7;
        const alpha = s.baseAlpha * twinkle;

        ctx.beginPath();
        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function getTrailPoint(t, time) {
      // t: 0..1
      const baseX = t;
      const baseY = 1 - t;
      const phase = time * trail.phaseSpeed;
      const offset = trail.amplitude * Math.sin(trail.frequency * t * Math.PI * 2 + phase);
      return { x: baseX, y: baseY + offset };
    }

    function drawLuminousTrail(time) {
      const segments = 220;

      // Brilho principal da trilha com sombra
      ctx.save();

      const flicker = 0.5 + 0.2 * Math.sin(time * 0.003);
      const lineWidth = Math.max(4, 10 * flicker);

      ctx.shadowBlur = 40;
      ctx.shadowColor = 'rgba(180, 230, 255, 0.9)';

      const grad = ctx.createLinearGradient(0, canvas.height, canvas.width, 0);
      grad.addColorStop(0.0, 'rgba(100, 160, 255, 0)');
      grad.addColorStop(0.2, 'rgba(160, 210, 255, 0.8)');
      grad.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
      grad.addColorStop(0.8, 'rgba(160, 220, 255, 0.8)');
      grad.addColorStop(1.0, 'rgba(100, 160, 255, 0)');
      ctx.strokeStyle = grad;
      ctx.lineWidth = lineWidth;

      ctx.beginPath();
      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const p = getTrailPoint(t, time);
        const x = normToPixelX(p.x);
        const y = normToPixelY(p.y);
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
      ctx.restore();

      // Halo suave ao redor da trilha (um pouco mais largo e translúcido)
      ctx.save();
      ctx.lineWidth = lineWidth * 2.2;
      ctx.strokeStyle = 'rgba(160, 220, 255, 0.12)';
      ctx.beginPath();
      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const p = getTrailPoint(t, time);
        const x = normToPixelX(p.x);
        const y = normToPixelY(p.y);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawNebulas() {
      for (const n of nebulas) {
        const x = normToPixelX(n.x);
        const y = normToPixelY(n.y);
        const r = normRadiusToPixels(n.radius);

        const grad = ctx.createRadialGradient(x, y, 0, x, y, r);
        grad.addColorStop(0, n.color1);
        grad.addColorStop(1, n.color2);
        ctx.beginPath();
        ctx.fillStyle = grad;
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawPlanet(p, time) {
      const floatOffset = Math.sin(time * 0.0005 + p.floatPhase) * 0.01;
      const x = normToPixelX(p.x);
      const y = normToPixelY(p.y + floatOffset);
      const r = normRadiusToPixels(p.radius);

      const grad = ctx.createRadialGradient(x - r * 0.3, y - r * 0.3, r * 0.1, x, y, r);
      grad.addColorStop(0, p.colorInner);
      grad.addColorStop(1, p.colorOuter);

      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = grad;
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();

      // Anel, se houver
      if (p.hasRing) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(-0.4);
        ctx.beginPath();
        ctx.lineWidth = r * 0.25;
        ctx.strokeStyle = 'rgba(255, 240, 200, 0.7)';
        ctx.ellipse(0, 0, r * 1.4, r * 0.6, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }

      ctx.restore();
    }

    function drawMoon(m, time) {
      const floatOffset = Math.sin(time * 0.0007 + m.floatPhase) * 0.008;
      const x = normToPixelX(m.x);
      const y = normToPixelY(m.y + floatOffset);
      const r = normRadiusToPixels(m.radius);

      ctx.save();

      // Halo suave
      const haloGrad = ctx.createRadialGradient(x, y, 0, x, y, r * 2);
      haloGrad.addColorStop(0, 'rgba(255, 255, 220, 0.75)');
      haloGrad.addColorStop(1, 'rgba(255, 255, 220, 0)');
      ctx.fillStyle = haloGrad;
      ctx.beginPath();
      ctx.arc(x, y, r * 2, 0, Math.PI * 2);
      ctx.fill();

      // Disco principal
      const grad = ctx.createRadialGradient(x - r * 0.3, y - r * 0.3, r * 0.1, x, y, r);
      grad.addColorStop(0, '#ffffff');
      grad.addColorStop(1, m.color);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();

      // Fase (crescente/minguante) desenhada com recorte
      if (m.phase === 'crescent' || m.phase === 'waning') {
        ctx.save();
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        const dir = (m.phase === 'crescent') ? 1 : -1;
        ctx.ellipse(x + dir * r * 0.35, y, r * 0.95, r * 1.05, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      ctx.restore();
    }

    // Desenha todas as luas normalmente (com câmera já aplicada)
    function drawMoons(time) {
      for (const m of moons) {
        drawMoon(m, time);
      }
    }

    // Desenhar todas as luas novamente, mas uma específica em destaque usando coordenadas de tela
    function drawFocusedMoonOverlay(moon, time) {
      // Converte posição da lua para coordenadas de tela (sem usar transformações do contexto)
      const c = camera.current;
      const cxPix = normToPixelX(c.x);
      const cyPix = normToPixelY(c.y);
      const floatOffset = Math.sin(time * 0.0007 + moon.floatPhase) * 0.008;

      const worldPixX = normToPixelX(moon.x);
      const worldPixY = normToPixelY(moon.y + floatOffset);
      const scale = c.scale;

      const sx = (worldPixX - cxPix) * scale + canvas.width / 2;
      const sy = (worldPixY - cyPix) * scale + canvas.height / 2;
      const r = normRadiusToPixels(moon.radius) * scale;

      // Halo forte
      ctx.save();
      const haloGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, r * 3);
      haloGrad.addColorStop(0, 'rgba(255, 255, 230, 0.95)');
      haloGrad.addColorStop(1, 'rgba(255, 255, 230, 0)');
      ctx.fillStyle = haloGrad;
      ctx.beginPath();
      ctx.arc(sx, sy, r * 3, 0, Math.PI * 2);
      ctx.fill();

      // Disco principal
      const grad = ctx.createRadialGradient(sx - r * 0.3, sy - r * 0.3, r * 0.1, sx, sy, r);
      grad.addColorStop(0, '#ffffff');
      grad.addColorStop(1, moon.color);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(sx, sy, r, 0, Math.PI * 2);
      ctx.fill();

      // Fase novamente
      if (moon.phase === 'crescent' || moon.phase === 'waning') {
        ctx.save();
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        const dir = (moon.phase === 'crescent') ? 1 : -1;
        ctx.ellipse(sx + dir * r * 0.35, sy, r * 0.95, r * 1.05, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      ctx.restore();
    }

    // ==========================
    // Interação (cliques)
    // ==========================

    function findClickedMoon(screenX, screenY) {
      const world = screenToWorldNormalized(screenX, screenY);

      for (const m of moons) {
        const dx = world.x - m.x;
        const dy = world.y - m.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        // Raio em coordenadas normalizadas (aproximação: usamos radius diretamente)
        if (dist <= m.radius * 1.4) { // um pouco de tolerância
          return m;
        }
      }
      return null;
    }

    function focusOnMoon(moon) {
      focusedMoonId = moon.id;
      camera.target.x = moon.x;
      camera.target.y = moon.y;
      camera.target.scale = 2.5; // zoom aproximado
    }

    function resetCamera() {
      focusedMoonId = null;
      camera.target.x = 0.5;
      camera.target.y = 0.5;
      camera.target.scale = 1.0;
    }

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;
      const clicked = findClickedMoon(sx, sy);
      if (clicked) {
        if (focusedMoonId === clicked.id) {
          // Se já está focada, volta à visão geral
          resetCamera();
        } else {
          focusOnMoon(clicked);
        }
      } else {
        // Clique em vazio não mexe na câmera (mas poderia desfocar, se quisesse)
      }
    });

    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' || e.key === 'Esc') {
        resetCamera();
      }
    });

    // ==========================
    // Loop de animação
    // ==========================
    let lastTime = 0;

    function render(timestamp) {
      const time = timestamp; // ms

      updateCamera();

      // Limpa fundo
      ctx.save();
      drawBackground();
      ctx.restore();

      // Desenha estrelas e nebulosas no espaço da tela (não afetadas pelo zoom)
      ctx.save();
      drawStars(time * 0.002);
      drawNebulas();
      ctx.restore();

      // Desenhar elementos ligados ao "mundo" com transformação de câmera
      ctx.save();
      applyCameraTransform();

      drawLuminousTrail(time);
      for (const p of planets) drawPlanet(p, time);
      drawMoons(time);

      ctx.restore();

      // Se há lua focada, escurece o restante da cena e destaca a lua
      if (focusedMoonId !== null) {
        ctx.save();

        // Escurece o resto da cena levemente
        ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Desenha a lua destacada por cima
        const moon = moons.find(m => m.id === focusedMoonId);
        if (moon) {
          drawFocusedMoonOverlay(moon, time);
        }

        ctx.restore();
      }

      lastTime = time;
      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  </script>
</body>
</html>
